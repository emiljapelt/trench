
let end_test = int:() {
    let b = 0;
    let a = 1 / b;
};

let current_test = 0;
let assertions = 0;
let has_failed = 0;

let assert = int:(int v) {
    if (has_failed) return 0;
    assertions++;
    if (v) return 0;
    else {
        has_failed = 1;
        say((current_test * 1000) + assertions);
    }
};

let test_case = int:(int test_id, int() test) {
    current_test = test_id;
    has_failed = 0;
    assertions = 0;
    test();
};

let clone = int:(int() f) {
    let _id = id;
    projection();
    if (_id == id) return 0;
    else f();
};


// START


// move
test_case(1, int:() {
    let prev_y = y;
    let prev_x = x;
    wall(N);
    wall(E);
    assert(!move(N));
    assert(!move(E));
    assert(prev_y == y);
    assert(prev_x == x);
    fireball(N);
    fireball(E);
    assert(move(N));
    assert(move(E));
    assert(prev_y != y);
    assert(prev_x != x);
});


// pager
test_case(2, int:() {
    pager_set(1337);

    clone(int:() {
        pager_write(123);
        end_test();
    });

    repeat 2 pass;
    assert(pager_read() == 123);

    clone(int:() {
        pager_write(123);
        end_test();
    });

    pager_set(420);
    repeat 2 pass;
    assert(pager_read() == 0);
});


// bridge/ocean
test_case(3, int:() {
    while(!(scan(W, 1) is @ocean)) move(W);

    clone(int:() {
        move(W);
        pager_write(420);
        end_test();
    });
    repeat 2 pass;
    assert(pager_read() == 0);

    bridge(W);

    clone(int:() {
        move(W);
        pager_write(420);
        end_test();
    });
    repeat 2 pass;
    assert(pager_read() == 420);

    bomb(W, 1);

    clone(int:() {
        move(W);
        pager_write(420);
        end_test();
    });
    repeat 2 pass;
    assert(pager_read() == 0);
});

// Tree
test_case(4, int:() {
    int prev = count(#sapling);
    plant_tree(E);
    assert(count(#sapling) < prev);
    repeat 3 pass;

    assert(scan(E, 1) is @tree);

    prev = x;
    move(E);
    assert(x == prev);

    prev = count(#sapling);
    collect(E);
    assert(count(#sapling) > prev);

    prev = count(#wood);
    chop(E);
    assert(count(#wood) > prev);
    assert(!(scan(E, 1) is @tree));

    let prev = x;
    move(E);
    assert(x != prev);
});

// Drop resources on death
test_case(5, int:() {
    drop(1, #wood);

    clone(int:() {
        take(1, #wood);
        move(E);
        end_test();
    });

    repeat 2 pass;
    let prev = count(#wood);
    take(1, #wood);
    assert(count(#wood) == prev);

    move(E);
    take(1, #wood);
    assert(count(#wood) == prev + 1);
});

// Can use boat
test_case(6, int:() {
    while(!(scan(W, 1) is @ocean)) move(W);

    boat(W);
    assert(mount(W));
    assert(move(W));
    assert(move(E));
    assert(move(E) == _OBSTRUCTED);
    assert(dismount(E));
});

// stack overflow kills
test_case(7, int:() {

    clone(int:() {
        this();
    });

    move(S);
    repeat 50 pass;
    assert(look(N, @player) == _OUT_OF_BOUNDS);
});

// function usage
test_case(8, int:() {

    let both = int:(int a, int b) {
        return a ? b : 0;
    };

    let either = int:(int a, int b) {
        return a ? 1 : b;
    };

    let not = int:(int a) {
        return !a;
    };

    assert(
        both(
            not(0),
            either(
                not(1),
                both(1, 1)
            )
        )
    );

    assert(
        not(
            both(1,0)
        )
    );
});

// null test
test_case(9, int:() {
    int() f;

    assert(f == null);

    f = int:() { return 1; };

    assert(f != null);

    f = null;

    assert(f == null);
});

end_test();