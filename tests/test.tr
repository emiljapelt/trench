
let end_test = int:() {
    let b = 0;
    let a = 1 / b;
};

let current_test = 0;
let assertions = 0;
let has_failed = 0;

let assert = int:(int v) {
    if (has_failed) return 0;
    assertions++;
    if (v) return 0;
    else {
        has_failed = 1;
        say((current_test * 1000) + assertions);
    }
};

let test_case = int:(int test_id, int() test) {
    current_test = test_id;
    has_failed = 0;
    assertions = 0;
    test();
};


// START


// move
test_case(1, int:() {
    let prev_y = y;
    let prev_x = x;
    wall(N);
    wall(E);
    assert(!move(N));
    assert(!move(E));
    assert(prev_y == y);
    assert(prev_x == x);
    fireball(N);
    fireball(E);
    assert(move(N));
    assert(move(E));
    assert(prev_y != y);
    assert(prev_x != x);
});


// pager
test_case(2, int:() {
    pager_set(1337);
    if (!projection()) {
        pager_write(123);
        end_test();
    }

    repeat 2 pass;
    assert(pager_read() == 123);


    if (!projection()) {
        pager_write(123);
        end_test();
    }
    pager_set(420);
    repeat 2 pass;
    assert(pager_read() == 0);
});


// bridge/ocean
test_case(3, int:() {
    while(!(scan(W, 1) is @ocean)) move(W);

    if (!projection()) {
        move(W);
        pager_write(420);
        end_test();
    }
    repeat 2 pass;
    assert(pager_read() == 0);

    bridge(W);

    if (!projection()) {
        move(W);
        pager_write(420);
        end_test();
    }
    repeat 2 pass;
    assert(pager_read() == 420);

    bomb(W, 1);

    if (!projection()) {
        move(W);
        pager_write(420);
        end_test();
    }
    repeat 2 pass;
    assert(pager_read() == 0);
});

// Tree
test_case(4, int:() {
    int prev = count(#sapling);
    plant_tree(E);
    assert(count(#sapling) < prev);
    repeat 3 pass;

    assert(scan(E, 1) is @tree);

    prev = x;
    move(E);
    assert(x == prev);

    prev = count(#sapling);
    collect(E);
    assert(count(#sapling) > prev);

    prev = count(#wood);
    chop(E);
    assert(count(#wood) > prev);
    assert(!(scan(E, 1) is @tree));

    let prev = x;
    move(E);
    assert(x != prev);
});

// Drop resources on death
test_case(5, int:() {
    drop(1, #wood);

    if (!projection()) {
        take(1, #wood);
        move(E);
        end_test();
    }

    repeat 2 pass;
    let prev = count(#wood);
    take(1, #wood);
    assert(count(#wood) == prev);

    move(E);
    take(1, #wood);
    assert(count(#wood) == prev + 1);
});

// Can use boat
test_case(6, int:() {
    while(!(scan(W, 1) is @ocean)) move(W);

    boat(W);
    assert(mount(W));
    move(W);
    move(E);
    assert(dismount(E));
});

end_test();